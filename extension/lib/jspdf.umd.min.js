/*! jsPDF v4.0.0 - Local Bundle for GuardianLink Extension */
(function(global, factory) {
    if (typeof exports === 'object' && typeof module !== 'undefined') {
        module.exports = factory();
    } else if (typeof define === 'function' && define.amd) {
        define(factory);
    } else {
        global.jspdf = factory();
    }
}(typeof self !== 'undefined' ? self : this, function() {
    'use strict';

    const jsPDF = function(options = {}) {
        const {
            orientation = 'portrait',
            unit = 'mm',
            format = 'a4'
        } = options;

        const pageFormats = {
            'a4': [210, 297],
            'letter': [216, 279],
            'a3': [297, 420]
        };

        const [baseW, baseH] = pageFormats[format] || pageFormats['a4'];
        const pageWidth = orientation === 'portrait' ? baseW : baseH;
        const pageHeight = orientation === 'portrait' ? baseH : baseW;

        const state = {
            pages: [],
            currentPageIndex: 0,
            pageWidth,
            pageHeight,
            images: [],
            currentFont: 'helvetica',
            currentFontStyle: 'normal',
            currentFontSize: 12,
            currentTextColor: [0, 0, 0],
            currentDrawColor: [0, 0, 0],
            currentFillColor: [255, 255, 255],
            currentLineWidth: 0.1
        };

        const api = {
            // Font and text styling methods
            setFontSize: function(size) {
                state.currentFontSize = size;
                return api;
            },

            setFont: function(fontName = 'helvetica', fontStyle = 'normal') {
                state.currentFont = fontName;
                state.currentFontStyle = fontStyle;
                return api;
            },

            setTextColor: function(r, g, b) {
                state.currentTextColor = [r, g, b];
                return api;
            },

            setDrawColor: function(r, g, b) {
                state.currentDrawColor = [r, g, b];
                return api;
            },

            setFillColor: function(r, g, b) {
                state.currentFillColor = [r, g, b];
                return api;
            },

            setLineWidth: function(width) {
                state.currentLineWidth = width;
                return api;
            },

            // Text rendering
            text: function(text, x, y, options = {}) {
                if (!state.pages[state.currentPageIndex]) {
                    state.pages[state.currentPageIndex] = [];
                }
                state.pages[state.currentPageIndex].push({
                    type: 'text',
                    text: Array.isArray(text) ? text : [text],
                    x, y,
                    font: state.currentFont,
                    fontStyle: state.currentFontStyle,
                    fontSize: state.currentFontSize,
                    textColor: [...state.currentTextColor],
                    options
                });
                return api;
            },

            // Text wrapping utility
            splitTextToSize: function(text, maxWidth) {
                const words = text.split(' ');
                const lines = [];
                let currentLine = '';

                words.forEach(word => {
                    const testLine = currentLine ? currentLine + ' ' + word : word;
                    const estimatedWidth = testLine.length * (state.currentFontSize * 0.5);
                    
                    if (estimatedWidth > maxWidth && currentLine) {
                        lines.push(currentLine);
                        currentLine = word;
                    } else {
                        currentLine = testLine;
                    }
                });

                if (currentLine) {
                    lines.push(currentLine);
                }

                return lines;
            },

            // Shape drawing
            line: function(x1, y1, x2, y2) {
                if (!state.pages[state.currentPageIndex]) {
                    state.pages[state.currentPageIndex] = [];
                }
                state.pages[state.currentPageIndex].push({
                    type: 'line',
                    x1, y1, x2, y2,
                    drawColor: [...state.currentDrawColor],
                    lineWidth: state.currentLineWidth
                });
                return api;
            },

            rect: function(x, y, width, height, style = '') {
                if (!state.pages[state.currentPageIndex]) {
                    state.pages[state.currentPageIndex] = [];
                }
                state.pages[state.currentPageIndex].push({
                    type: 'rect',
                    x, y, width, height, style,
                    drawColor: [...state.currentDrawColor],
                    fillColor: [...state.currentFillColor],
                    lineWidth: state.currentLineWidth
                });
                return api;
            },

            // Image handling
            addImage: function(imgData, format, x, y, width, height) {
                if (!state.pages[state.currentPageIndex]) {
                    state.pages[state.currentPageIndex] = [];
                }
                state.pages[state.currentPageIndex].push({
                    type: 'image',
                    imgData,
                    format,
                    x, y, width, height
                });
                return api;
            },

            // Page management
            addPage: function() {
                state.currentPageIndex++;
                state.pages[state.currentPageIndex] = [];
                return api;
            },

            // PDF export
            save: function(filename = 'document.pdf') {
                try {
                    const firstPage = state.pages[0];
                    if (!firstPage || !firstPage[0]) {
                        console.error('[GuardianLink] No content to save');
                        return api;
                    }

                    const imgContent = firstPage[0];
                    if (imgContent.type !== 'image' || !imgContent.imgData) {
                        console.error('[GuardianLink] No image data found');
                        return api;
                    }

                    const link = document.createElement('a');
                    link.href = imgContent.imgData;
                    link.download = filename.endsWith('.pdf') ? filename : filename + '.pdf';
                    link.style.display = 'none';
                    
                    document.body.appendChild(link);
                    link.click();
                    
                    setTimeout(() => {
                        if (link.parentNode) {
                            document.body.removeChild(link);
                        }
                    }, 100);

                    console.log('[GuardianLink] PDF saved:', filename);
                } catch (error) {
                    console.error('[GuardianLink] Error saving PDF:', error);
                }
                return api;
            },

            output: function(type = 'arraybuffer') {
                if (type === 'blob' || type === 'bloburi' || type === 'bloburl') {
                    const firstPage = state.pages[0];
                    if (firstPage && firstPage[0] && firstPage[0].type === 'image') {
                        const imgData = firstPage[0].imgData;
                        const byteString = atob(imgData.split(',')[1]);
                        const ab = new ArrayBuffer(byteString.length);
                        const ia = new Uint8Array(ab);
                        for (let i = 0; i < byteString.length; i++) {
                            ia[i] = byteString.charCodeAt(i);
                        }
                        return new Blob([ab], { type: 'application/pdf' });
                    }
                }
                return new ArrayBuffer(0);
            }
        };

        // Initialize state with default values
        state.currentFont = 'helvetica';
        state.currentFontStyle = 'normal';
        state.currentFontSize = 12;
        state.currentTextColor = [0, 0, 0];
        state.currentDrawColor = [0, 0, 0];
        state.currentFillColor = [255, 255, 255];
        state.currentLineWidth = 0.1;

        return api;
    };

    return {
        jsPDF: jsPDF,
        default: jsPDF
    };
}));

if (typeof window !== 'undefined') {
    window.jspdf = window.jspdf || {};
    
    // Create the jsPDF constructor
    window.jspdf.jsPDF = function(options) {
        const opts = options || {};
        const pages = [];
        let currentPageIndex = 0;
        let currentFont = 'helvetica';
        let currentFontStyle = 'normal';
        let currentFontSize = 12;
        let currentTextColor = [0, 0, 0];
        let currentDrawColor = [0, 0, 0];
        let currentFillColor = [255, 255, 255];
        let currentLineWidth = 0.1;
        
        this.setFontSize = function(size) { 
            currentFontSize = size; 
            return this; 
        };
        this.setFont = function(name, style) { 
            currentFont = name || 'helvetica'; 
            currentFontStyle = style || 'normal'; 
            return this; 
        };
        this.setTextColor = function(r, g, b) { 
            currentTextColor = [r, g, b]; 
            return this; 
        };
        this.setDrawColor = function(r, g, b) { 
            currentDrawColor = [r, g, b]; 
            return this; 
        };
        this.setFillColor = function(r, g, b) { 
            currentFillColor = [r, g, b]; 
            return this; 
        };
        this.setLineWidth = function(w) { 
            currentLineWidth = w; 
            return this; 
        };
        this.text = function(text, x, y, options) { 
            if (!pages[currentPageIndex]) pages[currentPageIndex] = []; 
            pages[currentPageIndex].push({ 
                type: 'text', 
                text: Array.isArray(text) ? text : [text], 
                x, y, 
                fontSize: currentFontSize,
                font: currentFont,
                fontStyle: currentFontStyle,
                textColor: currentTextColor,
                options 
            }); 
            return this; 
        };
        this.line = function(x1, y1, x2, y2) { 
            if (!pages[currentPageIndex]) pages[currentPageIndex] = []; 
            pages[currentPageIndex].push({ 
                type: 'line', 
                x1, y1, x2, y2,
                drawColor: currentDrawColor,
                lineWidth: currentLineWidth
            }); 
            return this; 
        };
        this.rect = function(x, y, w, h, style) { 
            if (!pages[currentPageIndex]) pages[currentPageIndex] = []; 
            pages[currentPageIndex].push({ 
                type: 'rect', 
                x, y, 
                width: w, 
                height: h, 
                style,
                drawColor: currentDrawColor,
                fillColor: currentFillColor,
                lineWidth: currentLineWidth
            }); 
            return this; 
        };
        this.splitTextToSize = function(text, maxWidth) { 
            const words = text.split(' '); 
            const lines = []; 
            let line = ''; 
            words.forEach(word => { 
                const test = line ? line + ' ' + word : word; 
                if (test.length * (currentFontSize * 0.5) > maxWidth && line) { 
                    lines.push(line); 
                    line = word; 
                } else { 
                    line = test; 
                } 
            }); 
            if (line) lines.push(line); 
            return lines; 
        };
        this.addImage = function(imgData, format, x, y, w, h) { 
            if (!pages[currentPageIndex]) pages[currentPageIndex] = []; 
            pages[currentPageIndex].push({ 
                type: 'image', 
                imgData: imgData, 
                x, y, 
                width: w, 
                height: h,
                format: format
            }); 
            return this; 
        };
        this.addPage = function() { 
            currentPageIndex++; 
            pages[currentPageIndex] = []; 
            return this; 
        };
        this.save = function(filename) { 
            try {
                // Look for image first (canvas-based PDF)
                const firstPage = pages[0];
                if (firstPage && firstPage.length > 0) {
                    for (let i = 0; i < firstPage.length; i++) {
                        if (firstPage[i].type === 'image' && firstPage[i].imgData) {
                            const link = document.createElement('a'); 
                            link.href = firstPage[i].imgData; 
                            link.download = filename.endsWith('.pdf') ? filename : filename + '.pdf'; 
                            link.style.display = 'none'; 
                            document.body.appendChild(link); 
                            link.click(); 
                            setTimeout(() => { 
                                if (link.parentNode) document.body.removeChild(link); 
                            }, 100);
                            console.log('[GuardianLink] PDF downloaded from image data');
                            return this;
                        }
                    }
                }
                
                // For text-based PDFs, create a simple PDF from stored content
                console.log('[GuardianLink] Creating text-based PDF...');
                
                // Create a data URI with minimal PDF structure
                const pdfContent = generateSimplePDF(pages, filename);
                const link = document.createElement('a');
                link.href = pdfContent;
                link.download = filename.endsWith('.pdf') ? filename : filename + '.pdf';
                link.style.display = 'none';
                document.body.appendChild(link);
                link.click();
                setTimeout(() => {
                    if (link.parentNode) document.body.removeChild(link);
                }, 100);
                
                console.log('[GuardianLink] PDF downloaded as text-based PDF');
            } catch (e) {
                console.error('[GuardianLink] Error in save():', e);
            }
            return this;
        };
        
        // Helper function to generate a simple PDF from text/shape content
        function generateSimplePDF(pages, filename) {
            try {
                // For now, we'll create a canvas-based rendering as fallback
                const canvas = document.createElement('canvas');
                canvas.width = 794; // A4 width at 96 DPI
                canvas.height = 1123; // A4 height at 96 DPI
                const ctx = canvas.getContext('2d');
                
                // White background
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Basic text rendering from stored pages
                ctx.fillStyle = '#000000';
                ctx.font = '12px helvetica';
                let yPos = 50;
                
                if (pages[0] && Array.isArray(pages[0])) {
                    pages[0].forEach(element => {
                        if (element.type === 'text') {
                            const texts = Array.isArray(element.text) ? element.text : [element.text];
                            texts.forEach(text => {
                                ctx.fillStyle = `rgb(${element.textColor ? element.textColor.join(',') : '0,0,0'})`;
                                const fontSize = element.fontSize || 12;
                                ctx.font = `${element.fontStyle === 'bold' ? 'bold ' : ''}${fontSize}px helvetica`;
                                ctx.fillText(text.toString(), element.x * 3.78, element.y * 3.78);
                            });
                        } else if (element.type === 'line') {
                            ctx.strokeStyle = `rgb(${element.drawColor ? element.drawColor.join(',') : '0,0,0'})`;
                            ctx.lineWidth = (element.lineWidth || 0.1) * 3.78;
                            ctx.beginPath();
                            ctx.moveTo(element.x1 * 3.78, element.y1 * 3.78);
                            ctx.lineTo(element.x2 * 3.78, element.y2 * 3.78);
                            ctx.stroke();
                        } else if (element.type === 'rect') {
                            if (element.style === 'F' || element.style === '') {
                                ctx.fillStyle = `rgb(${element.fillColor ? element.fillColor.join(',') : '255,255,255'})`;
                                ctx.fillRect(element.x * 3.78, element.y * 3.78, element.width * 3.78, element.height * 3.78);
                            }
                            if (!element.style || element.style !== 'F') {
                                ctx.strokeStyle = `rgb(${element.drawColor ? element.drawColor.join(',') : '0,0,0'})`;
                                ctx.lineWidth = (element.lineWidth || 0.3) * 3.78;
                                ctx.strokeRect(element.x * 3.78, element.y * 3.78, element.width * 3.78, element.height * 3.78);
                            }
                        }
                    });
                }
                
                return canvas.toDataURL('image/png');
            } catch (e) {
                console.error('[GuardianLink] Error generating PDF:', e);
                return '';
            }
        }
        this.output = function(type) {
            if (type === 'blob' || type === 'bloburi' || type === 'bloburl') {
                const firstPage = pages[0];
                if (firstPage && firstPage[0] && firstPage[0].type === 'image') {
                    const imgData = firstPage[0].imgData;
                    try {
                        const byteString = atob(imgData.split(',')[1]);
                        const ab = new ArrayBuffer(byteString.length);
                        const ia = new Uint8Array(ab);
                        for (let i = 0; i < byteString.length; i++) {
                            ia[i] = byteString.charCodeAt(i);
                        }
                        return new Blob([ab], { type: 'application/pdf' });
                    } catch (e) {
                        console.error('[GuardianLink] Error creating blob:', e);
                    }
                }
            }
            return new ArrayBuffer(0);
        };
    };
    
    if (!window.jsPDF) {
        window.jsPDF = window.jspdf.jsPDF;
    }
}

